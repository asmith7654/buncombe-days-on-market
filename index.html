<!DOCTYPE html>
<!-- 
  Buncombe County Housing Market Analysis Tool
  
  Purpose: Interactive visualization of housing market data in Buncombe County,
  focusing on Days on Market (DOM) analysis for properties in different price ranges.
  
  Key Features:
  - Interactive map showing property locations with DOM-based color coding
  - DOM distribution visualizations (pie chart and histogram)
  - Statistical summaries of DOM data
  - Filtering capabilities by price range and geographic radius
  - Dynamic data updates based on user selections
-->
<html>
<head>
  <meta charset="utf-8" />
  <title>Buncombe County Housing - Days on Market</title>
  <!-- Ensure proper rendering and touch zooming on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- External Dependencies -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>

  <style>
    /* Base page styling */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      background: white;
    }

    /* Header styling - main title container */
    header {
      background-color: #2c3e50;
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 1.8rem;
      font-weight: bold;
      letter-spacing: 1px;
      user-select: none;
    }

    /* Main controls container */
    .controls {
      background: #fff;
      padding: 15px;
      border-bottom: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      gap: 10px;
      user-select: none;
      margin-bottom: 30px;
    }

    /* Filter box - contains data filter checkboxes */
    .filter-box {
      border: 1px solid #ccc;
      background: #fafafa;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      margin-bottom: 20px;
    }

    /* Filter section title */
    .filter-title {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
    }

    /* Toggle all checkbox container */
    .toggle-all-wrapper {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    /* Grid layout for filter checkboxes */
    .checkbox-grid {
      display: grid;
      grid-template-columns: repeat(5, auto);
      gap: 10px 20px;
      justify-content: center;
    }

    /* Individual checkbox label styling */
    .checkbox-grid label {
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
      cursor: pointer;
    }

    /* Charts and summary statistics container */
    .charts-summary-wrapper {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 40px;
      margin-top: 15px;
      margin-bottom: 30px;
    }

    /* Individual chart container */
    .chart-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: fit-content;
    }

    /* Chart title styling */
    .chart-title {
      font-weight: bold;
      font-size: 1.2rem;
      margin-bottom: 8px;
      user-select: none;
      text-align: center;
    }

    /* Canvas element styling for charts */
    canvas {
      background: white;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    /* Pie chart size constraints */
    #domPieChart {
      max-width: 300px;
      max-height: 300px;
    }

    /* Histogram size constraints */
    #domHistChart {
      max-width: 480px;
      max-height: 300px;
    }

    /* Summary statistics box styling */
    .summary-box {
      background: #fff;
      padding: 10px 20px;
      font-size: 14px;
      border: 1px solid #ccc;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      align-self: flex-start;
      width: 250px;
    }

    /* Summary box title */
    .summary-title {
      font-weight: bold;
      font-size: 1.2rem;
      margin-bottom: 8px;
      user-select: none;
      text-align: center;
    }

    /* Individual summary statistic entry */
    .summary-entry {
      margin-bottom: 6px;
    }

    /* Map container with padding and border */
    .map-border-container {
      background-color: white;
      padding: 10px 10px 10px 10px;
      border-left: 45px solid white;
      border-right: 45px solid white;
      border-bottom: 45px solid white;
    }

    /* Main map container */
    #map {
      height: 750px;
      width: 100%;
      border: 5px solid #ccc;
    }

    /* Map legend styling */
    .legend-box {
      position: absolute;
      width: 130px;
      bottom: 40px;
      left: 20px;
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      z-index: 1000;
      font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      user-select: none;
    }

    /* Legend color boxes */
    .legend-box i {
      width: 12px;
      height: 12px;
      display: inline-block;
      margin-right: 5px;
      border-radius: 2px;
    }

    /* Radius filter input container */
    .radius-filter {
      margin: 10px 0;
      text-align: center;
    }
    /* Radius filter input fields */
    .radius-filter input {
      padding: 5px;
      margin: 0 5px;
    }
  </style>
</head>
<body>

  <header>
    Buncombe County Housing — Days on Market
  </header>

  <!-- Control Panel Section -->
  <div class="controls">
    <!-- Data Filter Box -->
    <div class="filter-box">
      <div class="filter-title">Data Filters</div>

      <!-- Toggle All Checkbox -->
      <div class="toggle-all-wrapper">
        <label><input type="checkbox" id="toggleAll" checked> <strong>Toggle All</strong></label>
      </div>

      <!-- Price Range and Time Period Filters -->
      <div class="checkbox-grid">
        <label><input type="checkbox" value="1m_plus_july_sep.json" checked> $1M+ July–Sep</label>
        <label><input type="checkbox" value="1m_plus_oct_dec.json" checked> $1M+ Oct–Dec</label>
        <label><input type="checkbox" value="1m_plus_jan_mar.json" checked> $1M+ Jan–Mar</label>
        <label><input type="checkbox" value="1m_plus_april_june.json" checked> $1M+ April–June</label>
        <label><input type="checkbox" value="1m_plus_unsold.json" checked> $1M+ Unsold (≥90 DOM)</label>
        <label><input type="checkbox" value="500k_to_1m_july_sep.json" checked> $500K–$1M July–Sep</label>
        <label><input type="checkbox" value="500k_to_1m_oct_dec.json" checked> $500K–$1M Oct–Dec</label>
        <label><input type="checkbox" value="500k_to_1m_jan_mar.json" checked> $500K–$1M Jan–Mar</label>
        <label><input type="checkbox" value="500k_to_1m_april_june.json" checked> $500K–$1M April–June</label>
        <label><input type="checkbox" value="500k_to_1m_unsold.json" checked> $500K–$1M Unsold (≥90 DOM)</label>
      </div>

      <!-- Geographic Radius Filter Controls -->
      <div class="radius-filter">
        <input type="text" id="addressInput" placeholder="Enter address">
        <input type="number" id="radiusInput" placeholder="Radius (miles)" step="0.1">
        <button onclick="applyRadiusFilter()">Apply Radius Filter</button>
        <button onclick="clearRadiusFilter()">Clear Radius Filter</button>
      </div>

      <!-- Data Download Controls -->
      <div class="radius-filter">
        <button onclick="downloadVisibleData('csv')">Download Visible Data (CSV)</button>
        <button onclick="downloadVisibleData('json')">Download Visible Data (JSON)</button>
      </div>
    </div>

    <!-- Visualization Section -->
    <div class="charts-summary-wrapper">
      <!-- Pie Chart -->
      <div class="chart-wrapper">
        <div class="chart-title">DOM Category Distribution</div>
        <canvas id="domPieChart" width="300" height="300"></canvas>
      </div>
      <!-- Histogram -->
      <div class="chart-wrapper">
        <div class="chart-title">DOM Histogram (10-day bins)</div>
        <canvas id="domHistChart" width="480" height="300"></canvas>
      </div>
      <!-- Summary Statistics Box -->
      <div class="chart-wrapper">
        <div class="chart-title">DOM Summary Statistics</div>
        <div class="summary-box">
          <div id="summaryContent"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="map-border-container">
    <div id="map"></div>
  </div>

  <!-- External Libraries -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- Statistical Functions -->
  <script>
    function mean(arr) {
      return arr.reduce((a, b) => a + b, 0) / arr.length;
    }
    function stdDev(arr) {
      const avg = mean(arr);
      const squareDiffs = arr.map(val => Math.pow(val - avg, 2));
      return Math.sqrt(mean(squareDiffs));
    }

    function percentile(arr, p) {
      if (arr.length === 0) return null;
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = (p / 100) * (sorted.length - 1);
      const lower = Math.floor(idx);
      const upper = Math.ceil(idx);
      return lower === upper ? sorted[lower] : sorted[lower] + (sorted[upper] - sorted[lower]) * (idx - lower);
    }

    function mad(arr) {
      if (arr.length === 0) return null;
      const median = percentile(arr, 50);
      const absoluteDeviations = arr.map(x => Math.abs(x - median));
      return percentile(absoluteDeviations, 50); // median of absolute deviations
    }

    function updateSummaryStats(allDoms) {
      const contentDiv = document.getElementById("summaryContent");
      if (allDoms.length === 0) {
        contentDiv.innerHTML = '';
        return;
      }

      const statsHtml = `
        <div class="summary-entry"><b>Total Properties:</b> ${allDoms.length}</div>
        <div class="summary-entry"><b>Min:</b> ${Math.min(...allDoms)}</div>
        <div class="summary-entry"><b>Max:</b> ${Math.max(...allDoms)}</div>
        <div class="summary-entry"><b>Mean:</b> ${mean(allDoms).toFixed(1)}</div>
        <div class="summary-entry"><b>25th Percentile:</b> ${percentile(allDoms, 25).toFixed(1)}</div>
        <div class="summary-entry"><b>50th Percentile:</b> ${percentile(allDoms, 50).toFixed(1)}</div>
        <div class="summary-entry"><b>75th Percentile:</b> ${percentile(allDoms, 75).toFixed(1)}</div>
        <div class="summary-entry"><b>90th Percentile:</b> ${percentile(allDoms, 90).toFixed(1)}</div>
        <div class="summary-entry"><b>Standard Deviation:</b> ${stdDev(allDoms).toFixed(1)}</div>
        <div class="summary-entry"><b>Median Absolute Deviation:</b> ${mad(allDoms).toFixed(1)}</div>
      `;
      contentDiv.innerHTML = statsHtml;
    }
  </script>

  <script>
    // Initialize map centered on Buncombe County
    const map = L.map('map').setView([35.5951, -82.5515], 11);
    // Add OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // Add geocoding control if available
    if (typeof L.Control.Geocoder !== 'undefined') {
      L.Control.geocoder({
        geocoder: L.Control.Geocoder.nominatim(),
        defaultMarkGeocode: true
      }).addTo(map);
    }

    // State management for price range filtering
    let priceRangeState = "mixed";

    // Map legend setup
    const legend = L.control({ position: "bottomleft" });

    /**
     * Creates and returns the legend DOM element
     * @param {L.Map} map - The Leaflet map instance
     * @returns {HTMLElement} The legend container
     */
    legend.onAdd = function (map) {
      const div = L.DomUtil.create("div", "legend-box");
      const { labels, colors } = getCurrentBins();
      div.innerHTML = `<strong>Days on Market</strong><br>` +
        labels.map((label, i) =>
          `<i style="background:${colors[i]};"></i> ${label}<br>`
        ).join('');
      return div;
    };

    legend.addTo(map);

    /**
     * Updates the legend when DOM ranges change
     */
    function updateLegend() {
      if (legend && legend._map) {
        legend.remove();
        legend.addTo(map);
      }
    }

    // Store for map layers, keyed by data file name
    const layers = {};

    /**
     * Determines marker color based on DOM value
     * @param {number} dom - Days on Market value
     * @returns {string} Color code for the marker
     */
    function getColor(dom) {
      const { breaks, colors } = getCurrentBins();
      for (let i = 0; i < breaks.length - 1; i++) {
        if (dom >= breaks[i] && dom < breaks[i + 1]) return colors[i];
      }
      return colors[colors.length - 1];
    }

    /**
     * Updates the price range state based on active filters
     * Determines which DOM ranges to use based on selected property types
     */
    function updatePriceRangeState() {
      const checkboxes = Array.from(document.querySelectorAll('.filter-box input[type="checkbox"]'))
        .filter(cb => cb.checked && cb.value);

      let has500k = false;
      let has1m = false;

      // Check which price ranges are active
      checkboxes.forEach(cb => {
        if (cb.value.startsWith("500k_to_1m")) has500k = true;
        if (cb.value.startsWith("1m_plus")) has1m = true;
      });

      // Set appropriate state based on active filters
      if (has500k && !has1m) {
        priceRangeState = "500k-1m";
      } else if (!has500k && has1m) {
        priceRangeState = "1m+";
      } else if (has500k && has1m) {
        priceRangeState = "mixed";
      } else {
        priceRangeState = "none";
      }
    }

    /**
     * Returns DOM ranges and colors based on current price range state
     * @returns {Object} Configuration object with breaks, labels, and colors
     */
    function getCurrentBins() {
      if (priceRangeState === "500k-1m") {
        return {
          breaks: [0, 8, 31, 90, 9999],
          labels: ["0–7", "8–30", "31–89", "90+"],
          colors: ['#1a9641', '#9ce349', '#fdae61', '#db4b4d']
        };
      }
      if (priceRangeState === "1m+") {
        return {
          breaks: [0, 15, 90, 151, 9999],
          labels: ["0–14", "15–89", "90–150", "151+"],
          colors: ['#1a9641', '#9ce349', '#fdae61', '#db4b4d']
        };
      }
      // mixed or none
      return {
        breaks: [0, 11, 46, 121, 9999],
        labels: ["0–10", "11–45", "46–120", "121+"],
        colors: ['#1a9641', '#9ce349', '#fdae61', '#db4b4d']
      };
    }

    // Pie Chart Setup
    const pieCtx = document.getElementById("domPieChart").getContext("2d");
    const domPieChart = new Chart(pieCtx, {
      type: "pie",
      data: {
        labels: getCurrentBins().labels,
        datasets: [{
          data: new Array(getCurrentBins().labels.length).fill(0),
          backgroundColor: getCurrentBins().colors,
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        interaction: { mode: null }, // disables all interaction including hover
        plugins: {
          legend: {
            position: "bottom",
            labels: {
              boxWidth: 12,
              boxHeight: 12,
              padding: 10
            }
          },
          datalabels: {
            formatter: (value, context) => {
              if (value === 0) return '';
              const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
              const percent = total === 0 ? 0 : (value / total * 100).toFixed(1);
              return `${percent}% (${value})`;
            },
            color: "#000",
            font: {
              weight: "bold",
              size: 12
            }
          },
          tooltip: {
            enabled: false // fully disable hover tooltips
          }
        }
      },
      plugins: [ChartDataLabels]
    });

   // Initialize histogram chart
    const histCtx = document.getElementById("domHistChart").getContext("2d");
    const binSize = 10;
    const maxBin = 300;
    const histLabels = [];

    // Generate histogram bin labels
    for (let start = 0; start < maxBin; start += binSize) {
      histLabels.push(`${start}–${start + binSize - 1}`);
    }
    histLabels.push(`${maxBin}+`);

    // Configure histogram chart
    const domHistChart = new Chart(histCtx, {
      type: "bar",
      data: {
        labels: histLabels,
        datasets: [{
          label: 'Count',
          data: new Array(histLabels.length).fill(0),
          backgroundColor: '#4a90e2',
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          datalabels: {
            anchor: 'end',
            align: 'top',
            color: '#333',
            font: { weight: 'bold', size: 11 },
            formatter: (value) => value > 0 ? value : ''
          },
          tooltip: {
            enabled: true,
            callbacks: {
              label: context => `Count: ${context.parsed.y}`
            }
          }
        },
        scales: {
          x: {
            ticks: { maxRotation: 90, minRotation: 45 },
            title: { display: true, text: 'Days on Market' }
          },
          y: {
            beginAtZero: true,
            title: { display: true, text: 'Number of Properties' },
            ticks: { precision: 0 },
          }
        }
      },
      plugins: [ChartDataLabels]
    });

    /**
     * Updates the pie chart with new DOM category counts
     * @param {number[]} domCounts - Array of counts for each DOM category
     */
    function updatePieChart(domCounts) {
      const { labels, colors } = getCurrentBins();
      domPieChart.data.labels = labels;
      domPieChart.data.datasets[0].data = domCounts;
      domPieChart.data.datasets[0].backgroundColor = colors;
      domPieChart.update();
    }

    /**
     * Updates the histogram with new DOM values
     * @param {number[]} allDoms - Array of all DOM values to be binned
     */
    function updateHistChart(allDoms) {
      const binsCount = new Array(histLabels.length).fill(0);
      allDoms.forEach(dom => {
        if (dom >= maxBin) {
          binsCount[binsCount.length - 1]++;
        } else {
          const binIndex = Math.floor(dom / binSize);
          binsCount[binIndex]++;
        }
      });

      // Update data
      domHistChart.data.datasets[0].data = binsCount;

      // Dynamically update Y-axis suggestedMax
      const maxCount = Math.max(...binsCount);
      domHistChart.options.scales.y.suggestedMax = maxCount > 0 ? Math.ceil(maxCount * 1.1) : undefined;

      domHistChart.update();
    }

    /**
     * Loads and displays property data from a JSON file
     * @param {string} file - Path to the JSON file containing property data
     * @returns {Promise<void>}
     */
    async function loadLayer(file) {
      const res = await fetch(file);
      const data = await res.json();
      const layer = L.layerGroup();

      data.forEach(d => {
        // Skip invalid entries
        if (!d.lat || !d.lon || d['days on market'] === undefined || d['days on market'] === null) return;
        const color = getColor(d['days on market']);
      
        // Create popup content with property information
        const popup = `
          <b>Address:</b> ${d.address || 'N/A'}<br>
          <b>Price:</b> $${Number(d.price).toLocaleString()}<br>
          <b>Days on Market:</b> ${d['days on market']}<br>
          <b>Status:</b> ${d.status || 'N/A'}<br>
          <a href="${d.url || '#'}" target="_blank">View Listing</a>
        `;

        const latlng = [d.lat, d.lon];

        // Create three concentric circles for each property
        // Outer circle (largest, most transparent)
        L.circleMarker(latlng, {
          radius: 15,
          color: color,
          fillColor: color,
          fillOpacity: 0.2,
          weight: 0
        }).addTo(layer);

        // Middle circle
        L.circleMarker(latlng, {
          radius: 10,
          color: color,
          fillColor: color,
          fillOpacity: 0.4,
          weight: 0
        }).addTo(layer);

        // Inner circle (smallest, most opaque, contains popup)
        L.circleMarker(latlng, {
          radius: 3,
          color: color,
          fillColor: color,
          fillOpacity: 0.8,
          weight: 0
        }).bindPopup(popup).addTo(layer);
      });

      // Store and display the layer
      layers[file] = layer;
      layer.addTo(map);
      computeDOMStats();
    }

    /**
     * Toggles visibility of a data layer
     * @param {string} file - Path to the JSON file for the layer
     * @param {boolean} show - Whether to show or hide the layer
     */
    function toggleLayer(file, show) {
      if (show) {
        if (layers[file]) {
          map.addLayer(layers[file]);
        } else {
          loadLayer(file);
        }
      } else {
        if (layers[file]) map.removeLayer(layers[file]);
      }
      computeDOMStats();
    }

    // Variables for radius filter components
    let filterCenter = null;
    let filterRadiusMeters = null;
    let radiusCircle = null;
    let radiusMarker = null;
    let resizeHandle = null;

    // Define resize handle icon style
    const resizeIcon = L.divIcon({
      className: 'resize-icon',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: blue;
        border: 2px solid white;
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(0,0,0,0.5);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    });


     /**
     * Creates a draggable radius filter on the map
     * @param {L.LatLng} latlng - Center point for the radius
     * @param {number} radiusMiles - Initial radius in miles
     */
    function createDraggableRadius(latlng, radiusMiles) {
      // Remove old markers and circle
      if (radiusMarker) map.removeLayer(radiusMarker);
      if (radiusCircle) map.removeLayer(radiusCircle);
      if (resizeHandle) map.removeLayer(resizeHandle);

      filterCenter = latlng;
      filterRadiusMeters = radiusMiles * 1609.34;

      // Create main draggable marker
      radiusMarker = L.marker(latlng, { draggable: true }).addTo(map);

      // Create the circle
      radiusCircle = L.circle(latlng, {
        radius: filterRadiusMeters,
        color: 'blue',
        fillColor: 'blue',
        fillOpacity: 0.1,
        dashArray: '4,4',
        interactive: false
      }).addTo(map);

      // Compute where to put the resize handle (east edge)
      const offsetPoint = latlng.destinationPoint(90, radiusMiles); // 90° = east
      resizeHandle = L.marker(offsetPoint, {
        draggable: true,
        icon: resizeIcon
      }).addTo(map);
      resizeHandle.bindTooltip(
        `${(filterRadiusMeters / 1609.34).toFixed(2)} mi`,
        { permanent: true, direction: 'top', offset: [0, -10] }
      );

      // Dragging center marker
      radiusMarker.on('drag', () => {
        const newCenter = radiusMarker.getLatLng();
        radiusCircle.setLatLng(newCenter);
        filterCenter = newCenter;

        // Move resize handle relative to new center
        const newHandlePos = newCenter.destinationPoint(90, filterRadiusMeters / 1609.34);
        resizeHandle.setLatLng(newHandlePos);

        computeDOMStats();
      });

      // Dragging resize handle
      resizeHandle.on('drag', () => {
        const handlePos = resizeHandle.getLatLng();
        const distance = filterCenter.distanceTo(handlePos);
        filterRadiusMeters = distance;
        radiusCircle.setRadius(distance);

        const radiusMiles = (filterRadiusMeters / 1609.34).toFixed(2);
        resizeHandle.setTooltipContent(`${radiusMiles} mi`);

        computeDOMStats();
      });

      computeDOMStats();
    }

    L.LatLng.prototype.destinationPoint = function (brng, dist) {
      dist = dist / 6371;  // convert dist to angular distance in radians (Earth radius = 6371km)
      brng = brng * Math.PI / 180;  // convert degrees to radians

      const lat1 = this.lat * Math.PI / 180;
      const lon1 = this.lng * Math.PI / 180;

      const lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist) +
        Math.cos(lat1) * Math.sin(dist) * Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(lat1),
        Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2));

      return L.latLng(lat2 * 180 / Math.PI, lon2 * 180 / Math.PI);
    };

    /**
     * Apply radius filter using address input
     * Geocodes address and creates radius filter
     */
    function applyRadiusFilter() {
      const address = document.getElementById("addressInput").value;
      const radiusMiles = parseFloat(document.getElementById("radiusInput").value);

      if (!address || isNaN(radiusMiles)) {
        alert("Please enter a valid address and radius.");
        return;
      }

      const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;

      fetch(geocodeUrl)
        .then(response => response.json())
        .then(results => {
          if (!results || results.length === 0) {
            alert("Address not found.");
            return;
          }

          const { lat, lon } = results[0];
          const center = L.latLng(lat, lon);
          createDraggableRadius(center, radiusMiles);
          map.setView(center, 13);
        })
        .catch(error => {
          console.error("Geocoding error:", error);
          alert("Geocoding failed.");
        });
    }

    /**
     * Clear radius filter and remove all filter components
     */
    function clearRadiusFilter() {
      filterCenter = null;
      filterRadiusMeters = null;

      if (radiusCircle) {
        map.removeLayer(radiusCircle);
        radiusCircle = null;
      }

      if (radiusMarker) {
        map.removeLayer(radiusMarker);
        radiusMarker = null;
      }

      if (resizeHandle) {
        map.removeLayer(resizeHandle);
        resizeHandle = null;
      }

      computeDOMStats();
    }

    /**
     * Update marker colors based on current DOM ranges
     * Groups markers by location and updates all markers for each property
     */
    function updateMarkerColors() {
      Object.values(layers).forEach(layer => {
        if (!map.hasLayer(layer)) return;
        // Collect all markers in this layer
        const markers = [];
        layer.eachLayer(marker => {
          if (marker.options && [3, 10, 15].includes(marker.options.radius)) {
            markers.push(marker);
          }
        });
        // Group markers by lat/lon (since each property has 3 markers at the same spot)
        const markerGroups = {};
        markers.forEach(marker => {
          const latlng = marker.getLatLng();
          const key = `${latlng.lat},${latlng.lng}`;
          if (!markerGroups[key]) markerGroups[key] = [];
          markerGroups[key].push(marker);
        });
        // For each group, get DOM from the marker with popup (radius 3), then update all
        Object.values(markerGroups).forEach(group => {
          let dom = null;
          group.forEach(marker => {
            if (marker.options.radius === 3) {
              const content = marker.getPopup()?.getContent() || "";
              const match = content.match(/Days on Market:<\/b> (\d+)/);
              if (match) dom = parseInt(match[1]);
            }
          });
          if (dom === null) return;
          const color = getColor(dom);
          group.forEach(marker => {
            marker.setStyle({ color, fillColor: color });
          });
        });
      });
    }

    /**
     * Computes and updates all DOM (Days on Market) statistics and visualizations.
     * This function:
     * 1. Collects DOM values from visible properties
     * 2. Applies radius filtering if active
     * 3. Categorizes properties into DOM ranges
     * 4. Updates all visualizations with new data
     */
    function computeDOMStats() {
      // Get current DOM range breaks for categorization
      const { breaks } = getCurrentBins();
      // Initialize arrays for different visualization needs
      const domCounts = new Array(breaks.length - 1).fill(0); // for pie chart bins
      const allDoms = []; // for histogram bins

      // Process each visible layer
      Object.values(layers).forEach(layer => {
        if (!map.hasLayer(layer)) return;
          
        // Process each marker in the layer
        layer.eachLayer(marker => {
          // Only process markers with popups (radius 3 markers contain the property data)
          if (!marker.options || marker.options.radius !== 3) return;

          // Get marker location for radius filtering
          const latlng = marker.getLatLng();

          // Apply radius filter if active
          if (filterCenter && filterRadiusMeters !== null) {
            if (filterCenter.distanceTo(latlng) > filterRadiusMeters) return;
          }

          // Extract DOM value from marker popup
          const content = marker.getPopup()?.getContent() || "";
          const match = content.match(/Days on Market:<\/b> (\d+)/);
          if (!match) return;

          // Parse and store DOM value
          const dom = parseInt(match[1]);
          allDoms.push(dom);

          // Categorize DOM value into appropriate bin for pie chart
          for (let i = 0; i < breaks.length - 1; i++) {
            if (dom >= breaks[i] && dom < breaks[i + 1]) {
              domCounts[i]++;
              break;
            }
          }
        });
      });
      // Update all visualizations with new data
      updatePieChart(domCounts);
      updateHistChart(allDoms);
      updateSummaryStats(allDoms);
      updateLegend();
    }

    /**
     * Updates the state of the "Toggle All" checkbox based on individual checkbox states.
     * If all individual checkboxes are checked, the "Toggle All" checkbox will be checked.
     * Excludes the "Toggle All" checkbox itself from the evaluation.
     */
    function updateToggleAllState() {
      // Exclude the toggleAll checkbox itself from this check
      const checkboxes = Array.from(document.querySelectorAll('.filter-box input[type="checkbox"]'))
        .filter(cb => cb.id !== 'toggleAll');
      const allChecked = checkboxes.every(cb => cb.checked);
      document.getElementById("toggleAll").checked = allChecked;
    }

    // Initialize all data layer checkboxes and set up their event listeners
    document.querySelectorAll('.filter-box input[type="checkbox"]').forEach(checkbox => {
      // Skip toggleAll itself
      if (checkbox.id === 'toggleAll') return;

      // Initialize layer visibility based on checkbox state
      toggleLayer(checkbox.value, checkbox.checked);
      updatePriceRangeState();

      // Set up change event handler for individual checkboxes
      checkbox.addEventListener('change', () => {
        toggleLayer(checkbox.value, checkbox.checked);
        updateToggleAllState();
        updatePriceRangeState();
        updateMarkerColors();
        computeDOMStats();
      });
    });

    /**
     * Event handler for the "Toggle All" checkbox.
     * Implements an inverse logic where:
     * - If any checkboxes are checked, it will uncheck all
     * - If all checkboxes are unchecked, it will check all
     * This creates a more intuitive toggle behavior for users.
     */
    document.getElementById("toggleAll").addEventListener("click", function () {
      // Get all checkboxes except "Toggle All"
      const checkboxes = Array.from(document.querySelectorAll('.filter-box input[type="checkbox"]'))
        .filter(cb => cb.id !== 'toggleAll');
      
      // Determine the new state based on current checkbox states
      const anyChecked = checkboxes.some(cb => cb.checked);
      const newState = !anyChecked;

      // Update all checkboxes and their corresponding layers
      checkboxes.forEach(cb => {
        cb.checked = newState;
        toggleLayer(cb.value, newState);
      });

      // Update the "Toggle All" checkbox state
      this.checked = newState;

      // Update the visualization state
      updatePriceRangeState();
      updateMarkerColors();
      computeDOMStats()
    });

    /**
     * Downloads the currently visible markers data as CSV or JSON
     * @param {string} format - 'csv' or 'json'
     */
    function downloadVisibleData(format) {
      const visibleData = [];
      const layersToProcess = [];
      
      // Identify which layers need to be processed
      Object.entries(layers).forEach(([fileName, layer]) => {
        if (!map.hasLayer(layer)) return; // Skip if layer is not visible
        
        // Get checkbox for this layer to confirm it's selected
        const checkbox = document.querySelector(`input[value="${fileName}"]`);
        if (!checkbox || !checkbox.checked) return;
        
        layersToProcess.push(fileName);
      });
      
      if (layersToProcess.length === 0) {
        alert('No data layers are currently visible. Please enable some data filters first.');
        return;
      }
      
      let processedLayers = 0;
      
      // Process each layer
      layersToProcess.forEach(fileName => {
        fetch(fileName)
          .then(response => response.json())
          .then(data => {
            data.forEach(property => {
              // Skip invalid entries
              if (!property.lat || !property.lon || property['days on market'] === undefined || property['days on market'] === null) return;
              
              // Apply radius filter if active
              if (filterCenter && filterRadiusMeters) {
                const propertyLatLng = L.latLng(property.lat, property.lon);
                const distance = filterCenter.distanceTo(propertyLatLng);
                if (distance > filterRadiusMeters) return; // Skip if outside radius
              }
              
              // Include only original columns from JSON file
              const cleanProperty = {
                ...property // Include all original columns only
              };
              
              visibleData.push(cleanProperty);
            });
            
            processedLayers++;
            checkAndDownload();
          })
          .catch(error => {
            console.error(`Error fetching data from ${fileName}:`, error);
            processedLayers++;
            checkAndDownload();
          });
      });
      
      function checkAndDownload() {
        if (processedLayers >= layersToProcess.length) {
          if (visibleData.length === 0) {
            alert('No visible data to download. Please ensure some properties are visible on the map and within any active radius filter.');
            return;
          }
          
          if (format === 'csv') {
            downloadCSV(visibleData);
          } else if (format === 'json') {
            downloadJSON(visibleData);
          }
        }
      }
    }
    
    /**
     * Downloads data as CSV file
     * @param {Array} data - Array of property objects
     */
    function downloadCSV(data) {
      if (data.length === 0) return;
      
      // Get all unique keys for CSV headers
      const headers = Object.keys(data[0]);
      
      // Create CSV content
      let csvContent = headers.join(',') + '\n';
      
      data.forEach(row => {
        const values = headers.map(header => {
          let value = row[header];
          // Escape commas and quotes in CSV
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            value = '"' + value.replace(/"/g, '""') + '"';
          }
          return value;
        });
        csvContent += values.join(',') + '\n';
      });
      
      // Create and trigger download
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `buncombe_housing_visible_data_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
    
    /**
     * Downloads data as JSON file
     * @param {Array} data - Array of property objects
     */
    function downloadJSON(data) {
      const jsonContent = JSON.stringify(data, null, 2);
      
      // Create and trigger download
      const blob = new Blob([jsonContent], { type: 'application/json' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `buncombe_housing_visible_data_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
  </script>

</body>
</html>